#!/usr/bin/env python
#
# ******************************************************************************
#
# ELITE-A SCRIPT TO CONVERT ORIGINAL SOURCES FOR BEEBASM
#
# Written by Mark Moxon
#
# This script converts the original source files for Elite-A from Angus Duggan's
# proprietary source format to a version that assembles with BeebAsm.
#
# The original source files are in the "sources" folder alongside this script.
#
# To convert the files into a format that will assemble in BeebAsm, cd into the
# folder containing this script, and do the following:
#
#   python convert-original-to-beebasm.py
#
# This will convert the source files to BeebAsm format and save them into the
# "converted" folder. You can them assemble each of them using commands like
# this:
#
#   beebasm -i converted/a.tcode.asm
#
# This saves the assembled binary ("tcode" in this case) into the "output"
# folder.
#
# To build the full game you need to mirror the original multi-step assembly
# process, as follows:
#
# Assemble a.tcode to produce output/tcode:
#
#   beebasm -i converted/a.tcode.asm
#
# Assemble a.dcode to produce output/1.F
#
#   beebasm -i converted/a.dcode.asm
#
# Assemble a.icode to produce output/1.E
#
#   beebasm -i converted/a.icode.asm
#
# Assemble a.qcode to produce output/2.T
#
#   beebasm -i converted/a.qcode.asm
#
# Assemble a.qelite to produce output/2.H
#
#   beebasm -i converted/a.qelite.asm
#
# Assemble a.elite to produce output/ELITE
#
#   beebasm -i converted/a.elite.asm
#
# Finally, produce output/1.D like this:
#
#   beebasm -i 1.d.asm
#
# This last step simply concatenates the tcode and S.T binaries into one file.
# Note that the S.T binary that is incorporated into 1.D is not the same as the
# S.T ship file on the final game disc (though confusingly they have the same
# name). The S.T binary that's incorporated into 1.D contains the ships to be
# shown in the hanger, while the S.T file on the final game disc is one of the
# in-flight ship files.
#
# Now that we have finished the assembly process, we can create the final game
# disc as follows:
#
# Copy the 1.D, 1.E, 1.F, 2.H, 2.T and ELITE files that we just assembled to the
# game disc
#
# Copy the !BOOT, B.CONVERT and S.A to S.W files from this repository's
# "binaries" folder to the game disc
#
# Set the disc's boot option to *OPT 4 3
#
# This will create the exact Elite-A disc produced by the original sources.
#
# This is almost the same as the patched release that's generated by the
# modern build process in this repository (i.e. those built with the following
# command: "make encrypt verify release=patched"). There are two subtle
# differences, though, which means that the crc32 checksums for the 1.D and
# tcode files produced by the above will not match those produced by the
# modern build process in this repository. This is because:
#
#   * The repository version incorporates "background noise" that the original
#     BBC Micro assembly process includes in the binary, specifically in the
#     gap between the concatenated tcode and S.T binaries. In the above process
#     that gap is filled with zeroes by BeebAsm (in 1.d.asm), while the original
#     version included whatever random content was in memory at the time.
#
#   * The repository version fixes a bug in a.tcode that has the wrong price
#     for the Anaconda
#
# As a result, these are the checksums for the above process, compared to the
# results of a "make encrypt verify release=patched" command:
#
#   c80972e6        1.D     (this is d1ca0224 in the release=patched build)
#   b1447e60        1.E
#   14ee8b20        1.F
#   3d638042        2.H
#   81d6d436        2.T
#   171ccea5        ELITE
#   0e2d62be        tcode   (this is 327d4a76 in the release=patched build)
#
# ******************************************************************************

import re


source_folder = "sources/"
dest_folder = "converted/"

source_files = ["a.global",
                "a.tcode", "a.tcode_1", "a.tcode_2", "a.tcode_3",
                "a.dcode", "a.dcode_1", "a.dcode_2", "a.dcode_3",
                "a.icode", "a.icode_1", "a.icode_2", "a.icode_3",
                "a.qcode", "a.qcode_1", "a.qcode_2", "a.qcode_3", "a.qcode_4", "a.qcode_5", "a.qcode_6",
                "a.qship_1", "a.qship_2",
                "a.qelite",
                "a.elite"
                ]

re_label = re.compile(r'^([a-z0-9A-Z_]+):?(\s+.*)*$')
re_llabel = re.compile(r'(l_[0-9A-F]{4})')
re_instruction = re.compile(r'^\s*(.+)$')
re_labelinstruction = re.compile(r'^([a-z0-9A-Z_]+):?\s+(.+)$')
re_equa = re.compile(r'^\s*EQUA\s*"(.+)"$')
re_var = re.compile(r'^([a-z0-9A-Z_]+):?\s*EQU \s*(\$?)(.+)$')
re_get = re.compile(r'^\s+GET\s*"(.+)"$')


def process_file(input_file, output_file, source_file):
    code_defined = False

    for line in input_file:
        # Manual fixes for scoping and case issues that trigger BeebAsm errors
        if source_file == "a.qcode_4":
            line = line.replace("jmp_start3", "jmp_start3_dup")
        if source_file == "a.qcode_3":
            line = line.replace("_07c0", "_07C0")
            line = line.replace("_07e0", "_07E0")

        if line.endswith(".<\n"):
            continue

        a = re_llabel.search(line)
        while a and a.group(1) != a.group(1).lower():
            line = line.replace(a.group(1), a.group(1).lower())
            a = re_llabel.search(line)
        m = re_label.search(line)
        n = re_equa.search(line)
        p = re_instruction.search(line)
        q = re_var.search(line)
        r = re_get.search(line)
        s = re_labelinstruction.search(line)
        if "EQUD 2#" in line:
            line = line.replace("EQUD 2#", "EQUD %")
        elif s and not s.group(2).startswith("EQU "):
            line = "\n." + s.group(1) + "\n\n"
            if s.group(2).startswith("EQUA"):
                z = re_equa.search(s.group(2))
                line += ' EQUS "' + convert_equa(z.group(1)) + '"\n'
                line = line.replace('EQUS "", ', 'EQUS ').replace(', ""', '')
            else:
                line += " " + s.group(2).replace("$", "&") + "\n"
        elif q:
            amp = q.group(2).replace("$", "&")
            line = q.group(1) + " = " + amp + q.group(3).replace("$", "&").replace("PC", "P%") + "\n"
        elif m:
            line = "\n." + m.group(1) + "\n\n"
        elif n:
            line = ' EQUS "' + convert_equa(n.group(1)) + '"\n'
            line = line.replace('EQUS "", ', 'EQUS ').replace(', ""', '')
        elif r:
            line = 'INCLUDE "converted/' + r.group(1).replace(":0.", "").replace(":2.", "") + '.asm"\n'
        elif p:
            if p.group(1).startswith("LOAD"):
                line = line.replace("$FFFF", "$").replace("\tLOAD $", "LOAD% = &")
            elif p.group(1).startswith("EXEC"):
                line = line.replace("$FFFF", "$").replace("\tEXEC $", "EXEC% = &").replace("\tEXEC ", "\\EXEC = ")
            elif p.group(1).startswith("ORG"):
                if code_defined:
                    line = line.replace("$FFFF", "$").replace("\tORG $", "ORG &")
                else:
                    line = line.replace("$FFFF", "$").replace("\tORG $", "CODE% = &") + "ORG CODE%\n"
                    code_defined = True
            elif p.group(1).startswith("OPT"):
                if p.group(1).startswith("OPT CMOS"):
                    line = "CPU 1"
                else:
                    line = line.replace("\tOPT", "\\OPT")
            else:
                inst = p.group(1)
                if "#<" in inst:
                    inst = re.sub(r'#<(\w+)', r'#LO(\1)', inst)
                elif "#>" in inst:
                    inst = re.sub(r'#>(\w+)', r'#HI(\1)', inst)
                line = " " + inst.replace("$", "&") + "\n"
        output_file.write(line)


def convert_equa(equa):
    result = ""
    ctrl = False
    excl = False

    for char in equa:
        if ctrl:
            if char == '!':
                excl = True
                ctrl = False
                continue
            if char == '|':
                ascii = ord(char)
            else:
                ascii = ord(char) - 0x40
            if ascii < 0:
                ascii += 0x80
            if excl:
                ascii += 0x80
            result += '", &' + ('%02x' % ascii).upper() + ', "'
            ctrl = False
            excl = False
        elif char == '|':
            ctrl = True
        else:
            if excl:
                ascii = ord(char) + 0x80
                if ascii < 0:
                    ascii += 0x80
                result += '", &' + ('%02x' % ascii).upper() + ', "'
            else:
                result += char
            ctrl = False
            excl = False

    return result


for source_file in source_files:
    input = source_folder + source_file

    with open(input, "r", encoding="latin-1") as input_file:
        output = dest_folder + source_file + ".asm"
        print(".", end="", flush=True)

        with open(output, "w") as output_file:
            process_file(input_file, output_file, source_file)

            if source_file == "a.tcode":
                output_file.write('\nSAVE "output/tcode", CODE%, P%, LOAD%')
            if source_file == "a.dcode":
                output_file.write('\nSAVE "output/1.F", CODE%, P%, LOAD%')
            if source_file == "a.icode":
                output_file.write('\nSAVE "output/1.E", CODE%, P%, LOAD%')
            if source_file == "a.qcode":
                output_file.write('\nSAVE "output/2.T", CODE%, P%, LOAD%')
            if source_file == "a.qelite":
                output_file.write('\nSAVE "output/2.H", CODE%, P%, LOAD%')
            if source_file == "a.elite":
                output_file.write('\nCOPYBLOCK &DD00, P%, to_dd00')
                output_file.write('\nSAVE "output/ELITE", CODE%, to_dd00+dd00_len, LOAD%')

print()
